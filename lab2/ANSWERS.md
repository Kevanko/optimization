# Lab 2 — Ответы на вопросы и сравнительный анализ

## П.2 — Время выполнения алгоритмов

### Вычислительная сложность

- **NFDH:** O(m) — один проход по задачам, для каждой либо добавление на текущий уровень, либо открытие нового. Сортировка по высоте — O(m + 100) подсчётом.
- **FFDH:** O(m log L) при использовании турнирного дерева, где L — число уровней. Поиск первого подходящего уровня — O(log L), обновление дерева — O(log L). Сортировка — та же O(m).

### Зависимость времени от m

- С ростом **m** время работы **растёт**: у NFDH примерно линейно (O(m)), у FFDH — как m log L (L тоже растёт с m). На графике `plots/time_vs_m.pdf` видно рост времени с увеличением числа задач.

### Зависимость времени от n

- От параметра **n** (число ЭМ = ширина полосы) время зависит **слабо**: n задаёт только ширину полосы; число уровней L определяется упаковкой (высотами и ширинами задач), а не самим n. Поэтому при фиксированном m время при n=1024 и n=4096 близко.

---

## П.3 — Сравнительный анализ (10 наборов, m = 500…5000, n = 1024)

По результатам экспериментов (после `./run_experiments.sh` и `python3 analyze_results.py`):

| Алгоритм | E(ε)  | σ(ε)  |
|----------|--------|--------|
| NFDH     | ~0.33  | ~0.008 |
| FFDH     | ~0.05  | ~0.015 |

**Ответ:** на рассмотренных наборах задач **более точные расписания формировал FFDH** (математическое ожидание ε у FFDH существенно меньше, чем у NFDH). First Fit позволяет лучше заполнять уровни и уменьшать общую высоту упаковки.

График зависимости ε от m: `plots/epsilon_vs_m.pdf`.

---

## П.4 — Сравнительный анализ на наборах из протоколов (m = 500, 1000, 1500)

Наборы в стиле протоколов промышленных ВС (LLNL uBGL / Atlas / Thunder) формируются скриптом `run_experiments_workload.sh` (синтетические или из загруженного лога). Результаты пишутся в `results/epsilon_workload.csv`, анализ — в `analyze_results.py`.

**Ответ:** на этих наборах также **более точные расписания формировал FFDH** (E(ε) у FFDH меньше, чем у NFDH).

Для реальных логов: скачать данные с [Parallel Workloads Archive](http://www.cs.huji.ac.il/labs/parallel/workload/logs.html), преобразовать в строки `r_j t_j` (например, скриптом `workload_to_tasks.py`), положить в `data/workload_500.txt` и т.д. и перезапустить `run_experiments_workload.sh`.

---

## Контрольные вопросы

### 1. Определение мультипрограммного режима функционирования распределённых ВС

**Мультипрограммный режим** — такой режим работы распределённой вычислительной системы, при котором на множестве элементарных машин (ЭМ) одновременно решается **несколько параллельных задач**. Ресурсы (ЭМ) распределяются между задачами в соответствии с расписанием; в каждый момент времени каждая занятая ЭМ выполняет одну ветвь одной задачи. Цель — эффективная загрузка системы и минимизация времени завершения всех задач.

### 2. Содержательный смысл целевой функции (1)

Целевая функция **T(S) = max_j (τ_j + t_j)** — это **время окончания решения последней задачи** при расписании S (моменты начала τ_j и размещение ветвей по ЭМ). Минимизировать T(S) значит **завершить весь набор задач как можно раньше** при соблюдении ограничений (не больше n ветвей одновременно, ветви одной задачи на разных ЭМ).

### 3. Смысл ограничений (2)–(5)

- **(2)** В любой момент t суммарное число ветвей выполняемых задач не превосходит n — **не перегружаем систему**: число занятых ЭМ не больше общего числа ЭМ.
- **(3)** Ветви разных задач, выполняемые в один момент времени, размещены на **разных ЭМ** (нет одновременной выдачи одной ЭМ двум ветвям).
- **(4)** Каждая ветвь назначена на одну из ЭМ из множества {1, …, n}.
- **(5)** Момент начала каждой задачи — произвольное неотрицательное действительное число (допускается непрерывное время).

### 4. Почему задача (1)–(5) относится к трудноразрешимым задачам дискретной оптимизации

Задача является задачей **дискретной оптимизации**: размещение ветвей по ЭМ — дискретный выбор (x_ji ∈ {1, …, n}), моменты начала могут рассматриваться в дискретной постановке. Она **NP-трудная**: её сведение к задаче упаковки прямоугольников в полосу (2D Strip Packing) даёт известную NP-трудную задачу. Точное решение для большого m и n требует перебора, поэтому используются приближённые алгоритмы (NFDH, FFDH и др.).
